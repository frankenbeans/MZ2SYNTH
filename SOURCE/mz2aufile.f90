! ------------------------------------------------------------------------------
! MZ2AUFILE.F90
!
! SUN AUDIO FILE FORMAT HANDLING SUBROUTINES FOR MZ2
!
! COPYRIGHT (C) 2024 BY E. LAMPRECHT - ALL RIGHTS RESERVED.
! ------------------------------------------------------------------------------

MODULE Mz2AuFile
  USE ISO_C_BINDING
  USE PFlags
  IMPLICIT NONE

  INTEGER(C_INT32_T),PARAMETER :: DFMAGIC=INT(Z'2E736E64',C_INT32_T)  ! AU TYPE
  INTEGER(C_INT32_T),PARAMETER :: HDRSIZE=28                          ! HDR SIZE
  INTEGER(C_INT32_T),PARAMETER :: DATSIZE=INT(Z'FFFFFFFF',C_INT32_T)  ! UNKNOWN

  INTEGER,PARAMETER :: AUF_PCM_LINEAR_16B=3
  INTEGER,PARAMETER :: AUF_FLT_LINEAR_32B=6
  INTEGER,PARAMETER :: AUF_DEF_SAMPLERATE=44100
  INTEGER,PARAMETER :: AUF_DEF_NMCHANNELS=2
  LOGICAL,PARAMETER :: AUF_DEF_ENDIANNESS=.TRUE. ! Big-endian

  TYPE :: SunAu
     INTEGER            :: AUFU=0
     INTEGER(C_INT32_T) :: ENCD=AUF_FLT_LINEAR_32B
     INTEGER(C_INT32_T) :: SMPR=AUF_DEF_SAMPLERATE
     INTEGER(C_INT32_T) :: NCHN=AUF_DEF_NMCHANNELS
     LOGICAL            :: MCBE=AUF_DEF_ENDIANNESS
     LOGICAL            :: OVWT=.FALSE.
     INTEGER            :: BCUR=1
     INTEGER(KIND=C_INT8_T),POINTER :: BUFF(:)=>NULL()
  END TYPE SunAu

  INTERFACE Au_WrtSmp
     MODULE PROCEDURE Au_WrtSmp_I16
     MODULE PROCEDURE Au_WrtSmp_R32     
  END INTERFACE Au_WrtSmp

  INTERFACE Nord
     MODULE PROCEDURE Nord_I16
     MODULE PROCEDURE Nord_I32
     MODULE PROCEDURE Nord_R32
  END INTERFACE Nord
  
CONTAINS

  SUBROUTINE Au_WrtHdr(SNAU,AUFN,AUFU,ENCD,SMPR,NCHN,OVWT,STAT) 
    IMPLICIT NONE
    TYPE(SunAu)        :: SNAU
    CHARACTER(LEN=*)   :: AUFN
    INTEGER            :: AUFU
    INTEGER(C_INT32_T) :: ENCD,SMPR,NCHN
    LOGICAL            :: OVWT
    INTEGER            :: STAT
    INTENT(IN)    :: AUFN,AUFU,ENCD,SMPR,NCHN,OVWT
    INTENT(INOUT) :: SNAU,STAT
    ! --- VARIABLES ---
    INTEGER :: ZSMP,ZBUF,MS
    CHARACTER(LEN=:),ALLOCATABLE :: FSTA
    ! --- EXE CODE  ---
    SELECT CASE (ENCD)
    CASE (AUF_PCM_LINEAR_16B)
       ZSMP=2
    CASE (AUF_FLT_LINEAR_32B)
       ZSMP=4
    CASE DEFAULT
       GOTO 900
    END SELECT
    IF (SMPR.LT.8000.OR.SMPR.GT.48000) GOTO 910
    IF (NCHN.LT.1.OR.NCHN.GT.2)        GOTO 920
    SNAU%AUFU=AUFU
    SNAU%ENCD=ENCD
    SNAU%SMPR=SMPR
    SNAU%NCHN=NCHN
    SNAU%MCBE=MachBE()
    SNAU%OVWT=OVWT
    ZBUF=ZSMP*SNAU%SMPR*SNAU%NCHN
    ALLOCATE(SNAU%BUFF(1:ZBUF),STAT=MS)
    IF (MS.NE.0) GOTO 930
    IF (OVWT) THEN
       FSTA='REPLACE'
    ELSE
       FSTA='NEW'
    END IF
    OPEN(FILE=AUFN,UNIT=SNAU%AUFU,FORM='UNFORMATTED',ACCESS='STREAM', &
         POSITION='REWIND',ACTION='WRITE',STATUS=FSTA,IOSTAT=STAT)
    IF (STAT.NE.0) RETURN
    IF (PFL_VERB) WRITE(*,700) 'File '//TRIM(AUFN)//' opened in mode '&
                                      //TRIM(FSTA)//' on unit',SNAU%AUFU
    WRITE(SNAU%AUFU,IOSTAT=STAT) &
         Nord_I32((/DFMAGIC,HDRSIZE,DATSIZE,ENCD,SMPR,NCHN,0/),SNAU%MCBE)
    IF (PFL_VERB) THEN
       IF (.NOT.SNAU%MCBE) THEN
          WRITE(*,700) 'Hardware is little-endian so samples will be converted'
       END IF
       WRITE(*,700) 'Audio file header write status is',STAT
    END IF
    RETURN
    ! --- END CODE  ---
700 FORMAT('*INF (Au_WrtHdr):',1X,A,:,999(1x,I0))
800 FORMAT('*ERR (Au_WrtHdr): INVALID',1X,A,1X,'=',I0)
810 FORMAT('*ERR (Au_WrtHdr):',1X,A)
900 WRITE(*,800) 'ENCD',ENCD ; STOP    
910 WRITE(*,800) 'SMPR',SMPR ; STOP
920 WRITE(*,800) 'NCHN',NCHN ; STOP
930 WRITE(*,810) 'BUFFER ALLOCATION FAILED' ; STOP 
  END SUBROUTINE Au_WrtHdr

  SUBROUTINE Au_WrtSmp_I16(SNAU,AUDS,STAT)
    IMPLICIT NONE
    TYPE(SunAu)             :: SNAU
    INTEGER(KIND=C_INT16_T) :: AUDS(1:)
    INTEGER                 :: STAT
    INTENT(IN)    :: AUDS
    INTENT(INOUT) :: SNAU,STAT
    ! --- VARIABLES ---
    INTEGER,PARAMETER :: ZSMP=2
    INTEGER :: BS,BE,ZTFR
    ! --- EXE CODE  ---
    STAT=0 ! Fake out as OK unless there REALLY was a write error
    IF (SNAU%BCUR.GT.UBOUND(SNAU%BUFF,1)) THEN
       WRITE(SNAU%AUFU,IOSTAT=STAT) SNAU%BUFF
       IF (STAT.NE.0) RETURN
       SNAU%BCUR=1
    END IF
    ZTFR=ZSMP*SIZE(AUDS)
    BS=SNAU%BCUR
    BE=SNAU%BCUR+ZTFR-1
    SNAU%BUFF(BS:BE)=TRANSFER(Nord_I16(AUDS,SNAU%MCBE),SNAU%BUFF(BS:BE))
    SNAU%BCUR=BE+1
    ! --- END CODE  ---    
  END SUBROUTINE Au_WrtSmp_I16

  SUBROUTINE Au_WrtSmp_R32(SNAU,AUDS,STAT)
    IMPLICIT NONE
    TYPE(SunAu)             :: SNAU
    REAL(KIND=C_FLOAT)      :: AUDS(1:)
    INTEGER                 :: STAT
    INTENT(IN)    :: AUDS
    INTENT(INOUT) :: SNAU,STAT
    ! --- VARIABLES ---
    INTEGER,PARAMETER :: ZSMP=4
    INTEGER :: BS,BE,ZTFR
    ! --- EXE CODE  ---
    STAT=0 ! Fake out as OK unless there REALLY was a write error
    IF (SNAU%BCUR.GT.UBOUND(SNAU%BUFF,1)) THEN
       WRITE(SNAU%AUFU,IOSTAT=STAT) SNAU%BUFF
       IF (STAT.NE.0) RETURN
       SNAU%BCUR=1
    END IF
    ZTFR=ZSMP*SIZE(AUDS)
    BS=SNAU%BCUR
    BE=SNAU%BCUR+ZTFR-1
    SNAU%BUFF(BS:BE)=TRANSFER(Nord_R32(AUDS,SNAU%MCBE),SNAU%BUFF(BS:BE))
    SNAU%BCUR=BE+1
     ! --- END CODE  ---    
  END SUBROUTINE Au_WrtSmp_R32

  SUBROUTINE Au_Close(SNAU,STAT)
    IMPLICIT NONE
    TYPE(SunAu)             :: SNAU
    INTEGER                 :: STAT
    INTENT(INOUT) :: SNAU,STAT
    ! --- EXE CODE  ---
    IF (SNAU%BCUR.GT.1) THEN
       WRITE(SNAU%AUFU,IOSTAT=STAT) SNAU%BUFF(1:SNAU%BCUR-1)
       IF (STAT.NE.0) RETURN
       IF (PFL_VERB) WRITE(*,700) 'Buffer flushed into unit',SNAU%AUFU
    END IF
    CLOSE(SNAU%AUFU,IOSTAT=STAT)
    IF (PFL_VERB) THEN
       WRITE(*,700) 'Closed file unit',SNAU%AUFU
       WRITE(*,700) 'Status of operation is',STAT
    END IF    
    IF (ASSOCIATED(SNAU%BUFF)) DEALLOCATE(SNAU%BUFF)
    SNAU=SunAu()
    IF (PFL_VERB) WRITE(*,700) 'Buffer deallocated'
    RETURN
    ! --- END CODE  ---
700 FORMAT('*INF (Au_Close):',1X,A,:,999(1x,I0))
  END SUBROUTINE Au_Close

  PURE FUNCTION MachBE()
    IMPLICIT NONE
    LOGICAL :: MachBE
    ! --- VARIABLES ---
    INTEGER(KIND=C_INT8_T) :: TC(1:2)
    ! --- EXE CODE  ---
    TC=TRANSFER(INT(1,C_INT16_T),TC)
    MachBE=TC(1).EQ.0 ! .TRUE.=>BIG ENDIAN HARDWARE
    ! --- END CODE  ---
  END FUNCTION MachBE

  ELEMENTAL FUNCTION Nord_I16(I,MBE)
    IMPLICIT NONE
    INTEGER(KIND=C_INT16_T)            :: Nord_I16
    INTEGER(KIND=C_INT16_T),INTENT(IN) :: I
    LOGICAL,INTENT(IN)                 :: MBE
    ! --- EXE CODE ---
    Nord_I16=I
    IF (.NOT.MBE) THEN
       ! Little-endian machine
       CALL MVBITS(I,0,8,Nord_I16,8)
       CALL MVBITS(I,8,8,Nord_I16,0)
    END IF
    ! --- END CODE ---
  END FUNCTION Nord_I16

  ELEMENTAL FUNCTION Nord_I32(I,MBE)
    IMPLICIT NONE
    INTEGER(KIND=C_INT32_T)            :: Nord_I32
    INTEGER(KIND=C_INT32_T),INTENT(IN) :: I
    LOGICAL,INTENT(IN)                 :: MBE
    ! --- EXE CODE ---
    Nord_I32=I
    IF (.NOT.MBE) THEN
       ! Little-endian machine       
       CALL MVBITS(I, 0,8,Nord_I32,24)
       CALL MVBITS(I, 8,8,Nord_I32,16)
       CALL MVBITS(I,16,8,Nord_I32, 8)
       CALL MVBITS(I,24,8,Nord_I32, 0)
    END IF
    ! --- END CODE ---
  END FUNCTION Nord_I32

  ELEMENTAL FUNCTION Nord_R32(R,MBE)
    IMPLICIT NONE
    REAL(KIND=C_FLOAT)            :: Nord_R32
    REAL(KIND=C_FLOAT),INTENT(IN) :: R
    LOGICAL,INTENT(IN)            :: MBE
    ! --- VARIABLES ---
    INTEGER(KIND=C_INT32_T) :: I
    ! --- EXE CODE ---
    Nord_R32=R
    IF (.NOT.MBE) THEN
       ! Little-endian machine
       I=0 ! Shut -Wall up talking
       CALL MVBITS(TRANSFER(R,I), 0,8,I,24)
       CALL MVBITS(TRANSFER(R,I), 8,8,I,16)
       CALL MVBITS(TRANSFER(R,I),16,8,I, 8)
       CALL MVBITS(TRANSFER(R,I),24,8,I, 0)
       Nord_R32=TRANSFER(I,Nord_R32)
    END IF
    ! --- END CODE ---
  END FUNCTION Nord_R32
 
END MODULE Mz2AuFile
